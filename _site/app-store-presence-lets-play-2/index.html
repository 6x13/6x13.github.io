<p>In <a href="http://blog.6x13.com/app-store-presence-lets-play-1/">the first post of the series</a>, we learnt how to gather the data, now we are going to do some cleanup.</p>

<pre>This is #2 of the how-to series on custom store presence analysis and plotting using Python, Jupyter and lots of sciency-graphy libraries.

<a href="http://blog.6x13.com/app-store-presence-lets-play-1/">#1 - Let's Play: <strong>Scrape</strong></a>   <strong> [ DONE ]</strong>
<a href="http://blog.6x13.com/app-store-presence-lets-play-2/">#2 - Let's Play: <strong>Cleanup</strong></a>   <strong>&lt;&lt;</strong>
#3 - Let's Play: <strong>Optimize</strong><strong>  [ TODO ]</strong>
#4 - Let's Play: <strong>Analyze   [ TODO ]</strong>
#5 - Let's Play: <strong>Visualize [ TODO ]
</strong>#6 - <strong>...
</strong></pre>

<p><img class="aligncenter" src="https://media.giphy.com/media/kXBVtKjLxINji/giphy.gif" alt="cleanup" width="500" height="250" /></p>

<h6 id="where-were-we">Where Were We?</h6>

<p>Using the methods in the Let’s Play #1, I gathered global, day-by-day, August 2017 data for the App Store presence of our latest game, <a href="http://6x13.com/">Twiniwt</a>.</p>

<p>Below is the size of the dataset:</p>

<pre>[kenanb@6x13 twiniwt-1708]$ <em>du -hsc *</em>
4.0K 170801.json
4.0K 170802.json
1.5M 170803.json
1.5M 170804.json
1.5M 170805.json
728K 170806.json
728K 170807.json
...
684K 170830.json
732K 170831.json
<strong>23M total</strong></pre>

<p>Damn! Surely, it is time for cleanup and restructuring.</p>

<h6 id="scabbling-and-cleanup">Scabbling and Cleanup</h6>

<p>Let’s <code class="highlighter-rouge">python3</code> and import the required packages.</p>

<pre>import json, pprint</pre>

<p>For this post, all we need is <a href="https://www.python.org/downloads/">Python 3</a>, which I presume you already have. Even though it is completely optional for cleanup part of the series, I strongly suggest installing and using <a href="http://jupyter.org/">Jupyter Notebook</a> for data exploration. It is especially useful while trying to restructure the data for your needs.</p>

<p>We saved our daily feature data to a subdirectory in our working directory.</p>

<p>A <em>dataset corresponding to 2017-08-15</em> is saved as:</p>

<pre>./json/170815.json</pre>

<p>We want to loop over a period, say, <em>each day in August 2017</em>.</p>

<p>We need to generate the filepaths for the corresponding dates in the loop.</p>

<p>The year:</p>

<pre>y = 17</pre>

<p>The month:</p>

<pre>m = 8</pre>

<p>Loop for each day, generate basename for the file and concatenate the whole pathname.</p>

<pre>for d in range(31):
    date = "%02d%02d%02d" % (y, m, d+1)
    file_name = "json/" + date + '.json'</pre>

<p>Here, we read the dataset using the pathname we just created.</p>

<pre>with open(file_name) as data_file:
        data = json.load(data_file)</pre>

<p>Then, we immediately bypass all the garbage branches in the serialized dataset, and assign the key ‘rows’ to our data variable.</p>

<p>First, we need to have a look at the loaded data and find the path to ‘rows’.</p>

<pre>{
  "data": {
    "data": {
      "pagination": {
        "current": 0,
        "page_interval": 1000,
        "sum": 1
      },
      <strong>"rows":</strong> <strong>[

	  ...

      ],</strong>
      "csvPermissionCode": "PERMISSION_NOT_PASS",
      "columns": [

	  ...

      ],
      "fixedColumns": {
        "tableWidth": 150,
        "fixed": 1
      }
    },
    "permission": true
  },
  "success": true
}</pre>

<p>As you can see, this is what takes us to the ‘rows’:</p>

<pre>data = data['data']['data'].get('rows') or []</pre>

<p>You probably noticed, we didn’t simply do <code class="highlighter-rouge">data['data']['data']['rows']</code> because that path might not even exist, if for some reason your app is not in store that day.</p>

<h6 id="restructure">Restructure</h6>

<p>Cool, we got rid of immediate garbage, it’s time to clean up and restructure the actual row data.</p>

<p>Let’s see, this is a sample row in an App Annie Daily Featured response.</p>

<pre>[
  [
    {
      "image": "https://static-s.aa-cdn.net/img/ios/...",
      "type": "icon",
      "thumb": "https://static-s.aa-cdn.net/img/ios/..."
    }
  ],
  [
    "China",
    <strong>"CN"</strong>
  ],
  <strong>"iPhone"</strong>,
  <strong>"Board"</strong>,
  <strong>"Collection List"</strong>,
  "N/A",
  <strong>2</strong>,
  4,
  <strong>6</strong>,
  [
    {
      "existence": false,
      "detail": null,
      "label": <strong>"Featured Home"</strong>
    },
    {
      "existence": false,
      "detail": null,
      "label": <strong>"Board"</strong>
    },
    {
      "existence": true,
      "detail": {
        "position": [
          6
        ],
        "row": <strong>[
          4,
          4
        ]</strong>
      },
      "parent": <strong>"免费"</strong>,
      "label": "Twiniwt"
    }
  ],
  [
    "N/A",
    0,
    100,
    ""
  ]
]</pre>

<p>Above, I marked the data we want to keep in bold. The full details about the contents of the row are provided in the <a href="http://blog.6x13.com/app-store-presence-lets-play-1/">Store Presence on App Store #1 – Let’s Play: Scrape</a>.</p>

<p>We traverse the data, removing the garbage values from each row array (in reverse order, of course, so the indices for the garbage entities do not change during deletion.)</p>

<pre>for d in data:
        d.pop(10)
        d.pop(5)
        d.pop(0)</pre>

<p>The two-letter country code is enough, we don’t need the full name of the countries in each element of our dataset.</p>

<pre>d[0] = d[0][1]</pre>

<p>Shorten the ‘Featured Home’ category page name, to simply, ‘Home’.</p>

<pre>if ( d[2] == 'Featured Home' ): d[2] = 'Home'</pre>

<p>The way ‘Featured Path’ is structured is pretty complex for our needs. Let’s restructure it.</p>

<pre>n = []
        for r in d[7]:
            n.append(r['label'])
        n[-1] = d[7][-1]['parent']
        if ( n[0] == 'Featured Home' ):
            n[0] = 'Home'
        if ( n[-1].endswith('see more') ):
            n[-1] = n[-1][:-9]
            n.append('&gt;&gt;')
        d[5] = d[7][-1]['detail']['row']
        d[7] = n</pre>

<p>I am skipping the details on this one, as you might want to keep it, or arrange it differently.</p>

<p>Below is the cleaned-up sample data we get after the process.</p>

<pre>[
  "CN",
  "iPhone",
  "Board",
  "Collection List",
  2,
  [
    4,
    4
  ],
  6,
  [
    "Home",
    "Board",
    "免费"
  ]
]</pre>

<p>Now that we are finished with the dataset cleanup, let’s write it back to the file.</p>

<pre>with open(file_name, 'w') as out_file:
        json.dump(data, 
                  out_file, 
                  indent=2, 
                  ensure_ascii=False,
                  sort_keys=True)</pre>

<p>You can view and download the complete code gist below.</p>

<p>We scraped and cleaned up the data. It is now down to 3.4Mb from 23Mb, meaning we just got rid of garbage that amounts to ~86% of the dataset. Congratulations!</p>

<p>Yet, the data is still unsuitable for real-time processing. We will fix that in the next part of the series. Some entities are long strings while we could get away with enumerations, things like that. And while at it, let’s get rid of this JSON nonsense, shall we?</p>

<p>Oh, I almost forgot the coffee beans!</p>

<p><img class="size-full wp-image-149 aligncenter" src="http://blog.6x13.com/wp-content/uploads/2017/09/coffee_beans.png" alt="" width="310" height="175" srcset="http://blog.6x13.com/wp-content/uploads/2017/09/coffee_beans.png 310w, http://blog.6x13.com/wp-content/uploads/2017/09/coffee_beans-300x169.png 300w" sizes="(max-width: 310px) 100vw, 310px" /></p>

<p>Check back for Part 3 of the series! If you have any questions or advice, please comment below. Thank you!</p>
